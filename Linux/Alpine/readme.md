[alpine 官网](https://www.alpinelinux.org/)

```shell
# 使用 apk 软件包管理
# 查看文档
man apk
# 添加软件帮助
apk add --help
# 删除软件帮助
apk del --help
```

修改`/etc/apk/repositories`使用国内的软件源

http://mirrors.ustc.edu.cn/alpine/latest-stable/main

## VMWare ISO安装 alpine

#### alpine 各个版本的区别

+ standard：正常内核的标椎版，可以体验，但是如果安装到硬盘，需要联网
+ extended：正常内核完全版，可以安装到硬盘（包括虚拟机），不需要联网
+ netboot：正常内核，不可体验，必须联网
+ raspberry pi：树莓派专用
+ generic ARM：ARM芯片专用
+ mini root filesystem：最小的base根文件系统，没有包含内核，所以不可直接安装
+ virtual：虚拟系统专用内核，其他和标椎版一样，可以体验，不能安装到硬盘，需要联网（可以联网的情况下可以使用，优点是很小）
+ xen：Xen Hypervision版本

启动之后可以直接使用 `root` 登陆

```sh
# 列出硬盘，体验一下linux命令
fdisk -l
# 开始硬盘安装 alpine
setup-alpine
# 选择键盘布局
us
# 输入 hostname
localhost
# 选择可用的网络
done
# IP address for interfaces
# dhcp none ? static-ip

# manual network configuration
n
# passowrd for root
password
# timezone (? for list)
Asia/
# sub-timezone of 'Asia/'
Shanghai
# http/ftp proxy url
none
# 选择 ntp client 网络对时 busybox、openntpd chrony none
chrony
# mirror url to add,添加镜像地址
# f)detect and add fastest mirror from above list
# ssh server
openssh
# which disk(s) would like to use
# 注意！默认是none，应该选择要安装的硬盘
sda
# how use disk sys(安装系统)，data(数据保存)，lvm,lvmsys,lvmdata
# sys: traditional disk install
# data: data storage,not for the operating system
sys
# Erase
y
# complete,reboot
reboot
```

## 安装 ssh 服务

```shell
# 查看安装的软件，确定没有安装 ssh 服务
# VMWare安装完成后默认已经安装了 ssh
apk info | grep ssh
# 搜索 ssh 服务软件包
apk search ssh | sort
# 安装 ssh
apk add openssh
# 配置 ssh
vim /etc/ssh/sshd_config
# PermitRootLogin yes
# 重启/启动 ssh 服务
/etc/init.d/sshd start/restart
# 查看 ssh 进程
ps -ef | grep sshd
# 查看 ssh 状态
/etc/init.d/sshd status
# 通过 rc-service 查看 ssh 服务状态
rc-service sshd status
```

##### 体系结构

从内到外：

+ 引导其：全部的起点，比如：`grub2,syslinux,grub4dos`。
  
  > 运行中的`alpine`本身可以提供引导器的安装管理，但裸服务器中必须依靠外在力量提供：比如宿主系统，live系统，或者把硬盘挂载到其他活跃的系统上,引导器会加载内核+对应的内存盘

+ 内核：`kernel` `linux` 的内核
  
  > 内核运行起来之后，一切都由内核控制了。在启动器运行之前给内核传递`init`参数，虽然是引导阶段提供的参数，但这是内核的功能，没有参数的话就默认运行 `/sbin/init`

+ `init`：一个抽象的用户根进程——1号进程
  
  - 帮助`kernel`由不可接触到可接触，负责管理，守护整个用户空间服务和程序；
  - 不一定只是一个程序，可由一整套相关规范和子程序来组成
  - 一定有个起始点程序，`kernel`默认是 `/sbin/inti`
  - 有各种各样的init程序：`sysvinit,openrc,runit,upstart,systmd`，`alpine` 默认：`openrc`
  
  > 做一些硬件和软件初始化的工作，准备`alpine`的工作环境，绝大部分登录前的问题都是`init`阶段导致的，`openrc`的控制台是通过运行`agetty`服务形式提供的

+ `shell`：用户可接触的最底层程序
  
  - 用户的操作界面
  - 常见的有：`sh,ash,bash,csh,ksh,zsh`
  - 介于`init`和用户`app`之间的普通程序而已，一般不会自己退出，除非用户主动或崩溃
  - 用户的操作总在它的管辖内
  - `alpine`提供的默认`shell`是：`busybox`的`ash`
  
  > `shell`不会自己运行

+ 用户`app`

#### 引导配置

```bash
#****************************
# 引导器
# /boot/extlinux.conf
alpine:/boot# cat extlinux.conf
# Generated by update-extlinux 6.04_pre1-r9
DEFAULT menu.c32
PROMPT 0
MENU TITLE Alpine/Linux Boot Menu
MENU HIDDEN
MENU AUTOBOOT Alpine will be booted automatically in # seconds.
TIMEOUT 30
LABEL lts
  MENU DEFAULT
  MENU LABEL Linux lts
  LINUX vmlinuz-lts
  INITRD initramfs-lts
# init
  # 内核参数没有配置 init,默认启动 /sbin/init
  APPEND root=UUID=c9db9a40-6521-43ba-80b0-4d7b7015e93c modules=sd-mod,usb-storage,ext4 pax_nouderef quiet rootfstype=ext4

MENU SEPARATOR
#****************************
# 内核
# 两个内核文件
# initramfs-lts
# vmlinuz-lts
#****************************
# init
# init配置文件
alpine:~# cat /etc/inittab
# /etc/inittab
# init 的初始化操作

# 以下三行配置调起openrc系统，达到及符合传统sysv系统又使用openrc的效果
::sysinit:/sbin/openrc sysinit
::sysinit:/sbin/openrc boot
::wait:/sbin/openrc default

# init 产生的终端控制台由符合sysv的/sbin/init根据其/etc/inittab配置产生的
# Set up a couple of getty's
# tty1 必须得有，否则开机后系统就像卡死那样，除非手动切换到其他控制台
tty1::respawn:/sbin/getty 38400 tty1
tty2::respawn:/sbin/getty 38400 tty2
tty3::respawn:/sbin/getty 38400 tty3
tty4::respawn:/sbin/getty 38400 tty4
tty5::respawn:/sbin/getty 38400 tty5
tty6::respawn:/sbin/getty 38400 tty6

# Put a getty on the serial port
#ttyS0::respawn:/sbin/getty -L ttyS0 115200 vt100

# Stuff to do for the 3-finger salute
::ctrlaltdel:/sbin/reboot

# Stuff to do before rebooting
::shutdown:/sbin/openrc shutdown
#****************************
# shell
# 每个用户使用的是什么样的 shell
alpine:~# cat /etc/passwd | grep root
root:x:0:0:root:/root:/bin/ash
operator:x:11:0:operator:/root:/sbin/nologin
alpine:~# echo $?
0
alpine:~# echo $0
-ash

#****************************
#****************************
#****************************
```

## Windows/Linux上体验或安装 `alpine`

[grub4dos](http://grub4dos.chenall.net/)

#### XP

- 准备引导工具，下载非UEFI版本

- 准备 `VIRTUAL`版本镜像，被标椎版小，（标椎版`500M`，`virtual40M`），实体机器推荐使用标椎版

- `grub4dos`的主要文件`grldr`和`virtual iso`放入`xp C`盘根目录

- - [x] 显示文件夹的内容
  
  - [ ] 隐藏受保护的操作系统文件（推荐）
  
  - 
  
  - [ ] 不显示隐藏的文件和文件夹
  
  - [x] 显示所有文件和文件夹

- 编辑`boot.ini`文件（注意：去掉只读）
  
  - 最后一行添加 `c:\grldr=grub4dos`

- 添加`menu.lst`
  
  > ```tex
  > title alpine iso
  > partnew (hd0,3) 0 /alpine镜像文件.iso
  > map --mem /alpine镜像文件.iso (0xff)
  > map --hook
  > chainloader (0xff)
  > boot
  > ```

#### Win7

前提：

> + `grub4dos`2次引导
> + `bootice`添加`grub4dos`引导条目
> + 准备`alpine`镜像

+ `grub4dos`的主要文件`grldr`,`booticex64`和`extended iso`放入`C`盘根目录（标准内核版本可能不支持`grub4dos`模式，备选`virtual`）

+ 添加`grub4dos`的引导菜单并且配置相关启动菜单文件——以便引导`alpine`的`iso`文件
  
  > BCD > 智能编辑 > 添加 > 新建 实模式启动项（Grub/Linux）
  > 
  > + 启动磁盘：C:
  > 
  > + 启动分区：(NTFS,***GB,C:\)
  > 
  > + 菜单标题：grub4dos
  > 
  > + 启动文件：\grldr
  > 
  > 保存当前系统设置

+ 新建`menu.lst`
  
  > `grub4dos`要求`iso`文件不能有碎片，必须是连续的
  > 
  > ```tex
  > title alpine-iso
  > root (hd0,1)
  > partnew (hd0,3) 0 /alpine镜像文件.iso
  > map /alpine镜像文件.iso (0xff)
  > map --hook
  > chainloader (0xff)
  > boot
  > ```

+ 重启
  
  > ```powershell
  > # 可以验证iso文件是否有碎片，不过只能看不能处理
  > grub> blocklist /alpine镜像文件.iso
  > ```

#### Centos6

前提：

> + 准备`alpine`镜像
> + [e2fsprogs中的e4defrag工具整理碎片](https://www.cnblogs.com/jinzhenshui/p/14589613.html)
> + 提取`e4defrag`工具
> 
> ```shell
> # 整理碎片
> chmod a+rx e4defrag
> cp e4defrag /bin
> which e4defrag
> # /bin/e4defrag
> e4defrag -c alpine镜像文件.iso
> ```
> 
> + 准备`grub4dos`中的`grub.exe`放入

+ 准备的镜像、`grub.exe`放入`/boot`
  
  > ```shell
  > sync
  > reboot
  > ```

+ > 系统开启的一瞬间：
  > 
  > `ESC`键，进入`grub legacy`的引导菜单
  > 
  > `C`键，进入`grub legacy`的`shell`控制台
  > 
  > 通过键盘键入的方式，链式引导到grub4dos菜单（控制台）
  > 
  > ```sh
  > # 列出 possible paritions
  > root (hd0,
  > # 选择 num
  > root (hd0,0)
  > # 列出 possible files
  > kernel /grub
  > # 选择 file
  > kernel /grub.exe
  > boot
  > ```
  > 
  > 又进入CentOS的引导菜单，因为grub4dos本身就源自grub legacy，所以grub4dos的引导器会读取、并显示原来CentOS的引导菜单没什么好奇怪
  > 
  > `C`键，进入`grub4dos`的`shell`控制台
  > 
  > ```sh
  > # 列出文件 (;;。%······45#df)
  > ls (hd0,1)/
  > root (hd0,0)
  > # 验证iso文件是否有碎片
  > blocklist /alpine镜像文件.iso
  > # 输入 lst
  > partnew (hd0,3) 0 /alpine镜像文件.iso
  > map /alpine镜像文件.iso (0xff)
  > map --hook
  > chainloader (0xff)
  > boot
  > ```

#### Centos7

前提：

> + 准备`alpine`镜像
> 
> + [e2fsprogs中的e4defrag工具整理碎片](https://www.cnblogs.com/jinzhenshui/p/14589613.html)
> 
> + 提取`e4defrag`工具
> 
> + 准备`grub4dos`中的`grub.exe`放入
> 
> + `CentOS`系统的文件系统都是`xfs`的，`grub4dos`不能支持,创建一个`ext`分区来进行操作

+ 准备的镜像、`grub.exe` ,放入`/ext`分区
  
  > ```shell
  > # 整理碎片
  > # 添加 e4defrag 命令
  > chmod a+rx e4defrag
  > cp e4defrag /bin
  > which e4defrag
  > # /bin/e4defrag
  > # 检验是否有碎片
  > e4defrag -c alpine镜像文件.iso
  > 
  > sync
  > reboot
  > ```

+ > 系统开启的一瞬间：
  > 
  > `ESC`键，进入`grub legacy`的引导菜单
  > 
  > `C`键，进入`grub legacy`的`shell`控制台
  > 
  > 通过键盘键入的方式，链式引导到grub4dos菜单（控制台）
  > 
  > ```sh
  > # 列出 possible paritions
  > root (hd0,
  > # 选择 num
  > root (hd0,0)
  > # 列出 possible files
  > kernel /grub
  > # 选择 file
  > kernel /grub.exe
  > boot
  > ```
  > 
  > 又进入CentOS的引导菜单，因为grub4dos本身就源自grub legacy，所以grub4dos的引导器会读取、并显示原来CentOS的引导菜单没什么好奇怪
  > 
  > `C`键，进入`grub4dos`的`shell`控制台
  > 
  > ```sh
  > # 列出文件 (;;。%······45#df)
  > ls (hd0,1)/
  > root (hd0,0)
  > # 验证iso文件是否有碎片
  > blocklist /alpine镜像文件.iso
  > # 输入 lst
  > partnew (hd0,3) 0 /alpine镜像文件.iso
  > map /alpine镜像文件.iso (0xff)
  > map --hook
  > chainloader (0xff)
  > boot
  > ```

#### `chroot`方式安装 `MINI ROOT FILESYSTEM`

打开Debian操作系统

```shell
# 查看硬盘分区
lsblk
# 每个分区的文件格式
mount | grep sda
# 选择一个计划给 alpine 使用的分区
# 把 alpine镜像文件.iso 放入选定的分区
# 可选命令
mkfs.ext
mkfs.ext2  mkfs.ext3  mkfs.ext4
# 
mkfs.ext4 /dev/sda6
```

## 基本配置

```shell
# 查看时间
date
# 配置工具包
apk add alpine-conf
# 工具包的所有命令
apk manifest alpine-conf
# setup-timezone 设置时区
# setup-hostname 修改hostname
# setup-interfaces 配置网络
# setup-dns 修改dns
# 手动修改dns /etc/resolv.conf
# 手动修改网络配置 /etc/network/interfaces
# 查看本地时区
ls -l /etc/localtime
lrwxrwxrwx    1 root     root            28 Jul 28 00:52 /etc/localtime -> /etc/zoneinfo/Asia//Shanghai
# 重启 chronyd，进行网络对时
rc-service chronyd restart
# 是时间同步到 BIOS
hwclock -w
```

```bash
# 手动配置时间
date --help
# 开机启动项
re-update
# 关闭自动启动
re-update del chronyd
# 停止服务
rc-service chronyd status
rc-service chronyd stop
# 配置时间
date -s '2021-12-12 12:12:12' 
# 更新BIOS
hwclock -w
```

```bash
# localtime 写入bios
hwclock -w -l
# utc time 写入bios
hwclock -w -u
# 以UTC读取 BIOS 时间
hwclock -r -u
# 已本地时区读取 bios 时间
hwclock -r -l
```

通过hwclock进行本地对时，会检查adjtime配置，如果没有或者是UTC配置一切行为按照UTC执行

如果local配置，则会按照local模式执行

#### `busybox`的`ntpd`配置时间服务

整个互联网有必要有一个可信可用的方式来设置客户端服务器的时间。这就是“网络时间协议（ntp）”、及其实现！典型的实现有ntpd、openntpd、chrony等。

```bash
# 查看 busybox 命令
busybox
# busybox 包含htpd协议的实现
ntpd -h
# ntpd 同步时间,外网同步时间的配置在 /etc/ntp.conf
# 后续 ntpd 将高优先级持续在前台运行
ntpd -dnNl -I eth1
# 使用 ntpd 从指定ip同步时间
ntpd -dn -p ***.***.***.***
# cat /etc/local.d/README
# local.d 存放开机/关机执行的程序
# 创建 ntpd.start
```

```shell
#!/bin/sh
ntpd -l -I eth0
```

```shell
# 开机执行
chnod a+rx ntpd.start
```

`busybox`的`ntpd`客户端运行时，被其他进程修改了时间后，它将无法继续时间同步

`rc-service local restart` 重启 `local`后时间就同步了

#### `chrony`配置时间服务

```shell
# 检查 chrony 是否已经安装
apk info | grep chrony
# 安装 chrony
apk add chrony
```

```shell
# /etc/chrony/chrony.conf chrony的配置文件

# default config

# chrony 客户端同步时间
# server ntpd.aliyun.com iburst

# 几乎实时同步时间
# 实时 server ntpd.aliyun.com minpoll -l maxpoll 1
# 实时 makestep 1 -1

# 9 分钟左右同步到正确时间
# 延时 makestep 1 -1

pool pool.ntp.org iburst
initstepslew 10 pool.ntp.org
driftfile /var/lib/chrony/chrony.drift
rtcsync
cmdport 0

# chrony 时间服务器配置
bindaddress 192.168.26.130
allow 192.168.26.131
local
```

```bash
# chrony 服务添加开机启动
rc-update add chronyd
# 开启 chrony 服务
rc-service chronyd start
```

`chrony` 客户端同样无法纠正手动修改的时间

增加配置项`makestep 3 -1`这个配置项会让 `chronyd`服务`9`分钟左右同步到正确时间

`ftp`服务推荐`vsftpd`

#### nfs服务

```shell
# nfs 是linux系统内核的功能
# nfs 管理工具
apk info | grep nfs
# 安装 nfs 管理工具
apk add nfs-utils
# 配置 nfs 服务器的本质是配置导出目录点：位置、客户端、客户端权限
# /etc/exports
# 导出点 客户端（可选的权限控制及其他导出选项） 其他客户端 ...
# 客户端优先级由高到低：
# 
```

配置 nfs 服务器的本质是配置导出目录点：位置、客户端、客户端权限。

配置文件：`/etc/exports`

导出点 客户端（可选的权限控制及其他导出选项） 其他客户端 ...

客户端优先级由高到低：

+ 单个IP或者主机名
+ 一个网络段
+ 一组计算机：即域名中的某一部分为通配符 *
+ 所有计算机：即通配符 *

同一优先级按照配置的先后顺序

权限及其他选项（常见的选项：`sync`/`async` `rw`/`wo` `root_quash`/`no_rrot_suqash` `subtree_check`/`no_subtree_check`）

```shell
# nfs 配置示例
# 要有配置的目录 /data IP应该是全位
/data 192.168.161.0/24(rw,no_root_squash,no_subtree_check) 192.168.0.0/16(ro,no_root_squash,no_subtree_check)
```

```shell
# 添加nfs服务到openrc
rc-update add nfs
# 启动 nfs 服务
rc-service nfs restart
# 查看导出目录列表
exportfs -s 
```

```bash
# nfs客户端
# 从指定nfs服务导出目录
mount.nfs 192.168.161.128:/data /mnt
# 查看mount列表
mount
```

#### 打开`net.ipv4.ip_forward`配置路由器

`/etc/sysctl.d/ip_forward.conf`
